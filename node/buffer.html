
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <title>Buffer · fe-books</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.1.0">
        <meta name="author" content="laomu1988@qq.com">
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
        

    

    
        
    

        

    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="addons.html" />
    
    
    <link rel="prev" href="assert.html" />
    

<link rel="stylesheet" href="/fe-books/server/index.css"/>

    </head>
    <body>
        
<script src="/fe-books/server/vue.min.js"></script>
<nav class="fe-menu">
	<ul>
		<li><a href="/fe-books/assist/index.html">说明</a></li>
		<li><a href="/fe-books/react/index.html">react</a></li>
		<li>
			<a href="/fe-books/vue/index.html">vue.js</a>
			<ul class="sub">
				<li><a href="/fe-books/vue-router/index.html">vue-router</a></li>
			</ul>
		</li>
		<li>
			<a href="/fe-books/node/documentation.html">node</a>
			<ul class="sub">
				<li><a href="/fe-books/koa/index.html">koa</a></li>
			</ul>
		</li>
		<li><a href="/fe-books/es6/index.html">es6入门</a></li>
		<li>
			<a href="/fe-books/tools/index.html">工具</a>
			<ul class="sub">
				<li><a href="/fe-books/tools/git.html">git</a></li>
				<li><a href="/fe-books/tools/vim.html">vim</a></li>
				<li><a href="/fe-books/fis3/index.html">fis3</a></li>
			</ul>
		</li>
		<li class="menu-last"></li>
	</ul>
</nav>

<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="documentation.html">
            
                <a href="documentation.html">
            
                    
                    About these Docs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="synopsis.html">
            
                <a href="synopsis.html">
            
                    
                    Usage & Example
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="assert.html">
            
                <a href="assert.html">
            
                    
                    Assertion Testing
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.5" data-path="buffer.html">
            
                <a href="buffer.html">
            
                    
                    Buffer
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="addons.html">
            
                <a href="addons.html">
            
                    
                    C/C++ Addons
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="child_process.html">
            
                <a href="child_process.html">
            
                    
                    Child Processes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="cluster.html">
            
                <a href="cluster.html">
            
                    
                    Cluster
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="cli.html">
            
                <a href="cli.html">
            
                    
                    Command Line Options
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="console.html">
            
                <a href="console.html">
            
                    
                    Console
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="crypto.html">
            
                <a href="crypto.html">
            
                    
                    Crypto
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="debugger.html">
            
                <a href="debugger.html">
            
                    
                    Debugger
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.13" data-path="dns.html">
            
                <a href="dns.html">
            
                    
                    DNS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.14" data-path="domain.html">
            
                <a href="domain.html">
            
                    
                    Domain
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.15" data-path="errors.html">
            
                <a href="errors.html">
            
                    
                    Errors
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.16" data-path="events.html">
            
                <a href="events.html">
            
                    
                    Events
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.17" data-path="fs.html">
            
                <a href="fs.html">
            
                    
                    File System
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.18" data-path="globals.html">
            
                <a href="globals.html">
            
                    
                    Globals
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.19" data-path="http.html">
            
                <a href="http.html">
            
                    
                    HTTP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.20" data-path="https.html">
            
                <a href="https.html">
            
                    
                    HTTPS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.21" data-path="modules.html">
            
                <a href="modules.html">
            
                    
                    Modules
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.22" data-path="net.html">
            
                <a href="net.html">
            
                    
                    Net
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.23" data-path="os.html">
            
                <a href="os.html">
            
                    
                    OS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.24" data-path="path.html">
            
                <a href="path.html">
            
                    
                    Path
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.25" data-path="process.html">
            
                <a href="process.html">
            
                    
                    Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.26" data-path="punycode.html">
            
                <a href="punycode.html">
            
                    
                    Punycode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.27" data-path="querystring.html">
            
                <a href="querystring.html">
            
                    
                    Query Strings
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.28" data-path="readline.html">
            
                <a href="readline.html">
            
                    
                    Readline
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.29" data-path="repl.html">
            
                <a href="repl.html">
            
                    
                    REPL
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.30" data-path="stream.html">
            
                <a href="stream.html">
            
                    
                    Stream
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.31" data-path="string_decoder.html">
            
                <a href="string_decoder.html">
            
                    
                    String Decoder
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.32" data-path="timers.html">
            
                <a href="timers.html">
            
                    
                    Timers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.33" data-path="tls.html">
            
                <a href="tls.html">
            
                    
                    TLS/SSL
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.34" data-path="tty.html">
            
                <a href="tty.html">
            
                    
                    TTY
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.35" data-path="dgram.html">
            
                <a href="dgram.html">
            
                    
                    UDP/Datagram
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.36" data-path="url.html">
            
                <a href="url.html">
            
                    
                    URL
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.37" data-path="util.html">
            
                <a href="util.html">
            
                    
                    Utilities
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.38" data-path="v8.html">
            
                <a href="v8.html">
            
                    
                    V8
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.39" data-path="vm.html">
            
                <a href="vm.html">
            
                    
                    VM
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.40" data-path="zlib.html">
            
                <a href="zlib.html">
            
                    
                    ZLIB
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <a target="_blank" href="https://github.com/nodejs/node">
            
                    
                    GitHub Repo & Issue Tracker
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" >
            
                <a target="_blank" href="http://groups.google.com/group/nodejs">
            
                    
                    Mailing List
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Buffer</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="buffer">Buffer</h1>
<pre><code>Stability: 2 - Stable
</code></pre><p>Prior to the introduction of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> in ECMAScript 2015 (ES6), the
JavaScript language had no mechanism for reading or manipulating streams
of binary data. The <code>Buffer</code> class was introduced as part of the Node.js
API to make it possible to interact with octet streams in the context of things
like TCP streams and file system operations.</p>
<p>Now that <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> has been added in ES6, the <code>Buffer</code> class implements the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" _target="blank"><code>Uint8Array</code></a> API in a manner that is more optimized and suitable for Node.js&apos;
use cases.</p>
<p>Instances of the <code>Buffer</code> class are similar to arrays of integers but
correspond to fixed-sized, raw memory allocations outside the V8 heap.
The size of the <code>Buffer</code> is established when it is created and cannot be
resized.</p>
<p>The <code>Buffer</code> class is a global within Node.js, making it unlikely that one
would need to ever use <code>require(&apos;buffer&apos;).Buffer</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Creates a zero-filled Buffer of length 10.</span>
<span class="hljs-keyword">const</span> buf1 = Buffer.alloc(<span class="hljs-number">10</span>);

<span class="hljs-comment">// Creates a Buffer of length 10, filled with 0x1.</span>
<span class="hljs-keyword">const</span> buf2 = Buffer.alloc(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">// Creates an uninitialized buffer of length 10.</span>
<span class="hljs-comment">// This is faster than calling Buffer.alloc() but the returned</span>
<span class="hljs-comment">// Buffer instance might contain old data that needs to be</span>
<span class="hljs-comment">// overwritten using either fill() or write().</span>
<span class="hljs-keyword">const</span> buf3 = Buffer.allocUnsafe(<span class="hljs-number">10</span>);

<span class="hljs-comment">// Creates a Buffer containing [0x1, 0x2, 0x3].</span>
<span class="hljs-keyword">const</span> buf4 = Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

<span class="hljs-comment">// Creates a Buffer containing ASCII bytes [0x74, 0x65, 0x73, 0x74].</span>
<span class="hljs-keyword">const</span> buf5 = Buffer.from(<span class="hljs-string">&apos;test&apos;</span>);

<span class="hljs-comment">// Creates a Buffer containing UTF-8 bytes [0x74, 0xc3, 0xa9, 0x73, 0x74].</span>
<span class="hljs-keyword">const</span> buf6 = Buffer.from(<span class="hljs-string">&apos;t&#xE9;st&apos;</span>, <span class="hljs-string">&apos;utf8&apos;</span>);
</code></pre>
<h2 id="bufferfrom-bufferalloc-and-bufferallocunsafe"><code>Buffer.from()</code>, <code>Buffer.alloc()</code>, and <code>Buffer.allocUnsafe()</code></h2>
<p>In versions of Node.js prior to v6, <code>Buffer</code> instances were created using the
<code>Buffer</code> constructor function, which allocates the returned <code>Buffer</code>
differently based on what arguments are provided:</p>
<ul>
<li>Passing a number as the first argument to <code>Buffer()</code> (e.g. <code>new Buffer(10)</code>),
allocates a new <code>Buffer</code> object of the specified size. The memory allocated
for such <code>Buffer</code> instances is <em>not</em> initialized and <em>can contain sensitive
data</em>. Such <code>Buffer</code> instances <em>must</em> be initialized <em>manually</em> by using either
<a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> or by writing to the <code>Buffer</code> completely. While
this behavior is <em>intentional</em> to improve performance, development experience
has demonstrated that a more explicit distinction is required between creating
a fast-but-uninitialized <code>Buffer</code> versus creating a slower-but-safer <code>Buffer</code>.</li>
<li>Passing a string, array, or <code>Buffer</code> as the first argument copies the
passed object&apos;s data into the <code>Buffer</code>.</li>
<li>Passing an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a> returns a <code>Buffer</code> that shares allocated memory with
the given <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a>.</li>
</ul>
<p>Because the behavior of <code>new Buffer()</code> changes significantly based on the type
of value passed as the first argument, applications that do not properly
validate the input arguments passed to <code>new Buffer()</code>, or that fail to
appropriately initialize newly allocated <code>Buffer</code> content, can inadvertently
introduce security and reliability issues into their code.</p>
<p>To make the creation of <code>Buffer</code> instances more reliable and less error prone,
the various forms of the <code>new Buffer()</code> constructor have been <strong>deprecated</strong>
and replaced by separate <code>Buffer.from()</code>, <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a>, and
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> methods.</p>
<p><em>Developers should migrate all existing uses of the <code>new Buffer()</code> constructors
to one of these new APIs.</em></p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the provided
octets.</li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a>
returns a new <code>Buffer</code> that <em>shares</em> the same allocated memory as the given
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a>.</li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a> returns a new <code>Buffer</code> containing a <em>copy</em> of the
contents of the given <code>Buffer</code>.</li>
<li><a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(string[, encoding])</code></a> returns a new <code>Buffer</code>
containing a <em>copy</em> of the provided string.</li>
<li><a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc(size[, fill[, encoding]])</code></a> returns a &quot;filled&quot;
<code>Buffer</code> instance of the specified size. This method can be significantly
slower than <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> but ensures
that newly created <code>Buffer</code> instances never contain old and potentially
sensitive data.</li>
<li><a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe(size)</code></a> and
<a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow(size)</code></a> each return a
new <code>Buffer</code> of the specified <code>size</code> whose content <em>must</em> be initialized
using either <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> or written to completely.</li>
</ul>
<p><code>Buffer</code> instances returned by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> <em>may</em> be allocated off
a shared internal memory pool if <code>size</code> is less than or equal to half
<a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a>. Instances returned by <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> <em>never</em>
use the shared internal memory pool.</p>
<h3 id="the---zero-fill-buffers-command-line-option">The <code>--zero-fill-buffers</code> command line option</h3>
<!-- YAML
added: v5.10.0
-->
<p>Node.js can be started using the <code>--zero-fill-buffers</code> command line option to
force all newly allocated <code>Buffer</code> instances created using either
<code>new Buffer(size)</code>, <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>, <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> or
<code>new SlowBuffer(size)</code> to be <em>automatically zero-filled</em> upon creation. Use of
this flag <em>changes the default behavior</em> of these methods and <em>can have a significant
impact</em> on performance. Use of the <code>--zero-fill-buffers</code> option is recommended
only when necessary to enforce that newly allocated <code>Buffer</code> instances cannot
contain potentially sensitive data.</p>
<p>Example:</p>
<pre><code class="lang-txt">$ node --zero-fill-buffers
&gt; Buffer.allocUnsafe(5);
&lt;Buffer 00 00 00 00 00&gt;
</code></pre>
<h3 id="what-makes-bufferallocunsafe-and-bufferallocunsafeslow-unsafe">What makes <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> and <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a> &quot;unsafe&quot;?</h3>
<p>When calling <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> and <a href="#buffer_class_method_buffer_allocunsafeslow_size"><code>Buffer.allocUnsafeSlow()</code></a>, the
segment of allocated memory is <em>uninitialized</em> (it is not zeroed-out). While
this design makes the allocation of memory quite fast, the allocated segment of
memory might contain old data that is potentially sensitive. Using a <code>Buffer</code>
created by <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> without <em>completely</em> overwriting the memory
can allow this old data to be leaked when the <code>Buffer</code> memory is read.</p>
<p>While there are clear performance advantages to using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a>,
extra care <em>must</em> be taken in order to avoid introducing security
vulnerabilities into an application.</p>
<h2 id="buffers-and-character-encodings">Buffers and Character Encodings</h2>
<p><code>Buffer</code> instances are commonly used to represent sequences of encoded characters
such as UTF-8, UCS2, Base64 or even Hex-encoded data. It is possible to
convert back and forth between <code>Buffer</code> instances and ordinary JavaScript strings
by using an explicit character encoding.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;hello world&apos;</span>, <span class="hljs-string">&apos;ascii&apos;</span>);

<span class="hljs-comment">// Prints: 68656c6c6f20776f726c64</span>
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">&apos;hex&apos;</span>));

<span class="hljs-comment">// Prints: aGVsbG8gd29ybGQ=</span>
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">&apos;base64&apos;</span>));
</code></pre>
<p>The character encodings currently supported by Node.js include:</p>
<ul>
<li><p><code>&apos;ascii&apos;</code> - for 7-bit ASCII data only. This encoding is fast and will strip
the high bit if set.</p>
</li>
<li><p><code>&apos;utf8&apos;</code> - Multibyte encoded Unicode characters. Many web pages and other
document formats use UTF-8.</p>
</li>
<li><p><code>&apos;utf16le&apos;</code> - 2 or 4 bytes, little-endian encoded Unicode characters.
Surrogate pairs (U+10000 to U+10FFFF) are supported.</p>
</li>
<li><p><code>&apos;ucs2&apos;</code> - Alias of <code>&apos;utf16le&apos;</code>.</p>
</li>
<li><p><code>&apos;base64&apos;</code> - Base64 encoding. When creating a <code>Buffer</code> from a string,
this encoding will also correctly accept &quot;URL and Filename Safe Alphabet&quot; as
specified in <a href="https://tools.ietf.org/html/rfc4648#section-5" _target="blank">RFC4648, Section 5</a>.</p>
</li>
<li><p><code>&apos;latin1&apos;</code> - A way of encoding the <code>Buffer</code> into a one-byte encoded string
(as defined by the IANA in <a href="https://tools.ietf.org/html/rfc1345" _target="blank">RFC1345</a>,
page 63, to be the Latin-1 supplement block and C0/C1 control codes).</p>
</li>
<li><p><code>&apos;binary&apos;</code> - Alias for <code>&apos;latin1&apos;</code>.</p>
</li>
<li><p><code>&apos;hex&apos;</code> - Encode each byte as two hexadecimal characters.</p>
</li>
</ul>
<p><em>Note</em>: Today&apos;s browsers follow the <a href="https://encoding.spec.whatwg.org/" _target="blank">WHATWG spec</a> which aliases both &apos;latin1&apos; and
ISO-8859-1 to win-1252. This means that while doing something like <code>http.get()</code>,
if the returned charset is one of those listed in the WHATWG spec it&apos;s possible
that the server actually returned win-1252-encoded data, and using <code>&apos;latin1&apos;</code>
encoding may incorrectly decode the characters.</p>
<h2 id="buffers-and-typedarray">Buffers and TypedArray</h2>
<p><code>Buffer</code> instances are also <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array" _target="blank"><code>Uint8Array</code></a> instances. However, there are subtle
incompatibilities with the TypedArray specification in ECMAScript 2015.
For example, while <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/slice" _target="blank"><code>ArrayBuffer#slice()</code></a> creates a copy of the slice, the
implementation of <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> creates a view over the
existing <code>Buffer</code> without copying, making <a href="#buffer_buf_slice_start_end"><code>Buffer#slice()</code></a> far
more efficient.</p>
<p>It is also possible to create new <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> instances from a <code>Buffer</code> with
the following caveats:</p>
<ol>
<li><p>The <code>Buffer</code> object&apos;s memory is copied to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a>, not shared.</p>
</li>
<li><p>The <code>Buffer</code> object&apos;s memory is interpreted as an array of distinct
elements, and not as a byte array of the target type. That is,
<code>new Uint32Array(Buffer.from([1, 2, 3, 4]))</code> creates a 4-element <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array" _target="blank"><code>Uint32Array</code></a>
with elements <code>[1, 2, 3, 4]</code>, not a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array" _target="blank"><code>Uint32Array</code></a> with a single element
<code>[0x1020304]</code> or <code>[0x4030201]</code>.</p>
</li>
</ol>
<p>It is possible to create a new <code>Buffer</code> that shares the same allocated memory as
a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> instance by using the TypeArray object&apos;s <code>.buffer</code> property.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">2</span>);

arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5000</span>;
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">4000</span>;

<span class="hljs-comment">// Copies the contents of `arr`</span>
<span class="hljs-keyword">const</span> buf1 = Buffer.from(arr);

<span class="hljs-comment">// Shares memory with `arr`</span>
<span class="hljs-keyword">const</span> buf2 = Buffer.from(arr.buffer);

<span class="hljs-comment">// Prints: &lt;Buffer 88 a0&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);

<span class="hljs-comment">// Prints: &lt;Buffer 88 13 a0 0f&gt;</span>
<span class="hljs-built_in">console</span>.log(buf2);

arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6000</span>;

<span class="hljs-comment">// Prints: &lt;Buffer 88 a0&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);

<span class="hljs-comment">// Prints: &lt;Buffer 88 13 70 17&gt;</span>
<span class="hljs-built_in">console</span>.log(buf2);
</code></pre>
<p>Note that when creating a <code>Buffer</code> using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a>&apos;s <code>.buffer</code>, it is
possible to use only a portion of the underlying <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a> by passing in
<code>byteOffset</code> and <code>length</code> parameters.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">20</span>);
<span class="hljs-keyword">const</span> buf = Buffer.from(arr.buffer, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>);

<span class="hljs-comment">// Prints: 16</span>
<span class="hljs-built_in">console</span>.log(buf.length);
</code></pre>
<p>The <code>Buffer.from()</code> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from" _target="blank"><code>TypedArray.from()</code></a> (e.g. <code>Uint8Array.from()</code>) have
different signatures and implementations. Specifically, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> variants
accept a second argument that is a mapping function that is invoked on every
element of the typed array:</p>
<ul>
<li><code>TypedArray.from(source[, mapFn[, thisArg]])</code></li>
</ul>
<p>The <code>Buffer.from()</code> method, however, does not support the use of a mapping
function:</p>
<ul>
<li><a href="#buffer_class_method_buffer_from_array"><code>Buffer.from(array)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_buffer"><code>Buffer.from(buffer)</code></a></li>
<li><a href="#buffer_class_method_buffer_from_arraybuffer_byteoffset_length"><code>Buffer.from(arrayBuffer[, byteOffset [, length]])</code></a></li>
<li><a href="#buffer_class_method_buffer_from_str_encoding"><code>Buffer.from(string[, encoding])</code></a></li>
</ul>
<h2 id="buffers-and-es6-iteration">Buffers and ES6 iteration</h2>
<p><code>Buffer</code> instances can be iterated over using the ECMAScript 2015 (ES6) <code>for..of</code>
syntax.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);

<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   1</span>
<span class="hljs-comment">//   2</span>
<span class="hljs-comment">//   3</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> b <span class="hljs-keyword">of</span> buf) {
  <span class="hljs-built_in">console</span>.log(b);
}
</code></pre>
<p>Additionally, the <a href="#buffer_buf_values"><code>buf.values()</code></a>, <a href="#buffer_buf_keys"><code>buf.keys()</code></a>, and
<a href="#buffer_buf_entries"><code>buf.entries()</code></a> methods can be used to create iterators.</p>
<h2 id="class-buffer">Class: Buffer</h2>
<p>The <code>Buffer</code> class is a global type for dealing with binary data directly.
It can be constructed in a variety of ways.</p>
<h3 id="new-bufferarray">new Buffer(array)</h3>
<!-- YAML
deprecated: v6.0.0
-->
<pre><code>Stability: 0 - Deprecated: Use [`Buffer.from(array)`] instead.
</code></pre><ul>
<li><code>array</code> {Array} An array of bytes to copy from</li>
</ul>
<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Creates a new Buffer containing the ASCII bytes of the string &apos;buffer&apos;</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer([<span class="hljs-number">0x62</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>]);
</code></pre>
<h3 id="new-bufferbuffer">new Buffer(buffer)</h3>
<!-- YAML
deprecated: v6.0.0
-->
<pre><code>Stability: 0 - Deprecated: Use [`Buffer.from(buffer)`] instead.
</code></pre><ul>
<li><code>buffer</code> {Buffer} An existing <code>Buffer</code> to copy data from</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">&apos;buffer&apos;</span>);
<span class="hljs-keyword">const</span> buf2 = <span class="hljs-keyword">new</span> Buffer(buf1);

buf1[<span class="hljs-number">0</span>] = <span class="hljs-number">0x61</span>;

<span class="hljs-comment">// Prints: auffer</span>
<span class="hljs-built_in">console</span>.log(buf1.toString());

<span class="hljs-comment">// Prints: buffer</span>
<span class="hljs-built_in">console</span>.log(buf2.toString());
</code></pre>
<h3 id="new-bufferarraybuffer-byteoffset--length">new Buffer(arrayBuffer[, byteOffset [, length]])</h3>
<!-- YAML
deprecated: v6.0.0
-->
<pre><code>Stability: 0 - Deprecated: Use
[`Buffer.from(arrayBuffer[, byteOffset [, length]])`][`Buffer.from(arrayBuffer)`]
instead.
</code></pre><ul>
<li><code>arrayBuffer</code> {ArrayBuffer} The <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> or
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a></li>
<li><code>byteOffset</code> {Integer} Where to start copying from <code>arrayBuffer</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>length</code> {Integer} How many bytes to copy from <code>arrayBuffer</code>.
<strong>Default:</strong> <code>arrayBuffer.length - byteOffset</code></li>
</ul>
<p>When passed a reference to the <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> instance,
the newly created <code>Buffer</code> will share the same allocated memory as the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a>.</p>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">2</span>);

arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5000</span>;
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">4000</span>;

<span class="hljs-comment">// Shares memory with `arr`</span>
<span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer(arr.buffer);

<span class="hljs-comment">// Prints: &lt;Buffer 88 13 a0 0f&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

<span class="hljs-comment">// Changing the original Uint16Array changes the Buffer also</span>
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6000</span>;

<span class="hljs-comment">// Prints: &lt;Buffer 88 13 70 17&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="new-buffersize">new Buffer(size)</h3>
<!-- YAML
deprecated: v6.0.0
-->
<pre><code>Stability: 0 - Deprecated: Use [`Buffer.alloc()`] instead (also see
[`Buffer.allocUnsafe()`]).
</code></pre><ul>
<li><code>size</code> {Integer} The desired length of the new <code>Buffer</code></li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes.  The <code>size</code> must be less than or equal
to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown.
A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>
<p>Unlike <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffers</code></a>, the underlying memory for <code>Buffer</code> instances
created in this way is <em>not initialized</em>. The contents of a newly created <code>Buffer</code>
are unknown and <em>could contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a>
to initialize a <code>Buffer</code> to zeroes.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-number">5</span>);

<span class="hljs-comment">// Prints (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.fill(<span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 00 00 00 00 00&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="new-bufferstring-encoding">new Buffer(string[, encoding])</h3>
<!-- YAML
deprecated: v6.0.0
-->
<pre><code>Stability: 0 - Deprecated:
Use [`Buffer.from(string[, encoding])`][`Buffer.from(string)`] instead.
</code></pre><ul>
<li><code>string</code> {String} String to encode</li>
<li><code>encoding</code> {String} The encoding of <code>string</code>. <strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
</ul>
<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If
provided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">&apos;this is a t&#xE9;st&apos;</span>);

<span class="hljs-comment">// Prints: this is a t&#xE9;st</span>
<span class="hljs-built_in">console</span>.log(buf1.toString());

<span class="hljs-comment">// Prints: this is a tC)st</span>
<span class="hljs-built_in">console</span>.log(buf1.toString(<span class="hljs-string">&apos;ascii&apos;</span>));


<span class="hljs-keyword">const</span> buf2 = <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">&apos;7468697320697320612074c3a97374&apos;</span>, <span class="hljs-string">&apos;hex&apos;</span>);

<span class="hljs-comment">// Prints: this is a t&#xE9;st</span>
<span class="hljs-built_in">console</span>.log(buf2.toString());
</code></pre>
<h3 id="class-method-bufferallocsize-fill-encoding">Class Method: Buffer.alloc(size[, fill[, encoding]])</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li><code>size</code> {Integer} The desired length of the new <code>Buffer</code></li>
<li><code>fill</code> {String | Buffer | Integer} A value to pre-fill the new <code>Buffer</code> with.
<strong>Default:</strong> <code>0</code></li>
<li><code>encoding</code> {String} If <code>fill</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
</ul>
<p>Allocates a new <code>Buffer</code> of <code>size</code> bytes. If <code>fill</code> is <code>undefined</code>, the
<code>Buffer</code> will be <em>zero-filled</em>.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">5</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 00 00 00 00 00&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<p>The <code>size</code> must be less than or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>.
Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown. A zero-length <code>Buffer</code> will be created if
<code>size &lt;= 0</code>.</p>
<p>If <code>fill</code> is specified, the allocated <code>Buffer</code> will be initialized by calling
<a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill)</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">5</span>, <span class="hljs-string">&apos;a&apos;</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 61 61 61 61 61&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<p>If both <code>fill</code> and <code>encoding</code> are specified, the allocated <code>Buffer</code> will be
initialized by calling <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(fill, encoding)</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">11</span>, <span class="hljs-string">&apos;aGVsbG8gd29ybGQ=&apos;</span>, <span class="hljs-string">&apos;base64&apos;</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<p>Calling <a href="#buffer_class_method_buffer_alloc_size_fill_encoding"><code>Buffer.alloc()</code></a> can be significantly slower than the alternative
<a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> but ensures that the newly created <code>Buffer</code> instance
contents will <em>never contain sensitive data</em>.</p>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<h3 id="class-method-bufferallocunsafesize">Class Method: Buffer.allocUnsafe(size)</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li><code>size</code> {Integer} The desired length of the new <code>Buffer</code></li>
</ul>
<p>Allocates a new <em>non-zero-filled</em> <code>Buffer</code> of <code>size</code> bytes. The <code>size</code> must
be less than or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>. Otherwise, a
<a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown. A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>
<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not
initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and
<em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize such
<code>Buffer</code> instances to zeroes.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">5</span>);

<span class="hljs-comment">// Prints (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.fill(<span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 00 00 00 00 00&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<p>Note that the <code>Buffer</code> module pre-allocates an internal <code>Buffer</code> instance of
size <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> that is used as a pool for the fast allocation of new
<code>Buffer</code> instances created using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> (and the deprecated
<code>new Buffer(size)</code> constructor) only when <code>size</code> is less than or equal to
<code>Buffer.poolSize &gt;&gt; 1</code> (floor of <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a> divided by two).</p>
<p>Use of this pre-allocated internal memory pool is a key difference between
calling <code>Buffer.alloc(size, fill)</code> vs. <code>Buffer.allocUnsafe(size).fill(fill)</code>.
Specifically, <code>Buffer.alloc(size, fill)</code> will <em>never</em> use the internal <code>Buffer</code>
pool, while <code>Buffer.allocUnsafe(size).fill(fill)</code> <em>will</em> use the internal
<code>Buffer</code> pool if <code>size</code> is less than or equal to half <a href="#buffer_class_property_buffer_poolsize"><code>Buffer.poolSize</code></a>. The
difference is subtle but can be important when an application requires the
additional performance that <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> provides.</p>
<h3 id="class-method-bufferallocunsafeslowsize">Class Method: Buffer.allocUnsafeSlow(size)</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li><code>size</code> {Integer} The desired length of the new <code>Buffer</code></li>
</ul>
<p>Allocates a new <em>non-zero-filled</em> and non-pooled <code>Buffer</code> of <code>size</code> bytes. The
<code>size</code> must be less than or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>.
Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is thrown. A zero-length <code>Buffer</code> will be created if
<code>size &lt;= 0</code>.</p>
<p>The underlying memory for <code>Buffer</code> instances created in this way is <em>not
initialized</em>. The contents of the newly created <code>Buffer</code> are unknown and
<em>may contain sensitive data</em>. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize such
<code>Buffer</code> instances to zeroes.</p>
<p>When using <a href="#buffer_class_method_buffer_allocunsafe_size"><code>Buffer.allocUnsafe()</code></a> to allocate new <code>Buffer</code> instances,
allocations under 4KB are, by default, sliced from a single pre-allocated
<code>Buffer</code>. This allows applications to avoid the garbage collection overhead of
creating many individually allocated <code>Buffer</code> instances. This approach improves
both performance and memory usage by eliminating the need to track and cleanup as
many <code>Persistent</code> objects.</p>
<p>However, in the case where a developer may need to retain a small chunk of
memory from a pool for an indeterminate amount of time, it may be appropriate
to create an un-pooled <code>Buffer</code> instance using <code>Buffer.allocUnsafeSlow()</code> then
copy out the relevant bits.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Need to keep around a few small chunks of memory</span>
<span class="hljs-keyword">const</span> store = [];

socket.on(<span class="hljs-string">&apos;readable&apos;</span>, () =&gt; {
  <span class="hljs-keyword">const</span> data = socket.read();

  <span class="hljs-comment">// Allocate for retained data</span>
  <span class="hljs-keyword">const</span> sb = Buffer.allocUnsafeSlow(<span class="hljs-number">10</span>);

  <span class="hljs-comment">// Copy the data into the new allocation</span>
  data.copy(sb, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);

  store.push(sb);
});
</code></pre>
<p>Use of <code>Buffer.allocUnsafeSlow()</code> should be used only as a last resort <em>after</em>
a developer has observed undue memory retention in their applications.</p>
<p>A <code>TypeError</code> will be thrown if <code>size</code> is not a number.</p>
<h3 id="class-method-bufferbytelengthstring-encoding">Class Method: Buffer.byteLength(string[, encoding])</h3>
<!-- YAML
added: v0.1.90
-->
<ul>
<li><code>string</code> {String | Buffer | TypedArray | DataView | ArrayBuffer} A value to
calculate the length of</li>
<li><code>encoding</code> {String} If <code>string</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
<li>Return: {Integer} The number of bytes contained within <code>string</code></li>
</ul>
<p>Returns the actual byte length of a string. This is not the same as
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length" _target="blank"><code>String.prototype.length</code></a> since that returns the number of <em>characters</em> in
a string.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&apos;\u00bd + \u00bc = \u00be&apos;</span>;

<span class="hljs-comment">// Prints: &#xBD; + &#xBC; = &#xBE;: 9 characters, 12 bytes</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${str}</span>: <span class="hljs-subst">${str.length}</span> characters, `</span> +
            <span class="hljs-string">`<span class="hljs-subst">${Buffer.byteLength(str, &apos;utf8&apos;)}</span> bytes`</span>);
</code></pre>
<p>When <code>string</code> is a <code>Buffer</code>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" _target="blank"><code>DataView</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a>/<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a>, the
actual byte length is returned.</p>
<p>Otherwise, converts to <code>String</code> and returns the byte length of string.</p>
<h3 id="class-method-buffercomparebuf1-buf2">Class Method: Buffer.compare(buf1, buf2)</h3>
<!-- YAML
added: v0.11.13
-->
<ul>
<li><code>buf1</code> {Buffer}</li>
<li><code>buf2</code> {Buffer}</li>
<li>Return: {Integer}</li>
</ul>
<p>Compares <code>buf1</code> to <code>buf2</code> typically for the purpose of sorting arrays of
<code>Buffer</code> instances. This is equivalent to calling
<a href="#buffer_buf_compare_target_targetstart_targetend_sourcestart_sourceend"><code>buf1.compare(buf2)</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from(<span class="hljs-string">&apos;1234&apos;</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.from(<span class="hljs-string">&apos;0123&apos;</span>);
<span class="hljs-keyword">const</span> arr = [buf1, buf2];

<span class="hljs-comment">// Prints: [ &lt;Buffer 30 31 32 33&gt;, &lt;Buffer 31 32 33 34&gt; ]</span>
<span class="hljs-comment">// (This result is equal to: [buf2, buf1])</span>
<span class="hljs-built_in">console</span>.log(arr.sort(Buffer.compare));
</code></pre>
<h3 id="class-method-bufferconcatlist-totallength">Class Method: Buffer.concat(list[, totalLength])</h3>
<!-- YAML
added: v0.7.11
-->
<ul>
<li><code>list</code> {Array} List of <code>Buffer</code> instances to concat</li>
<li><code>totalLength</code> {Integer} Total length of the <code>Buffer</code> instances in <code>list</code>
when concatenated</li>
<li>Return: {Buffer}</li>
</ul>
<p>Returns a new <code>Buffer</code> which is the result of concatenating all the <code>Buffer</code>
instances in the <code>list</code> together.</p>
<p>If the list has no items, or if the <code>totalLength</code> is 0, then a new zero-length
<code>Buffer</code> is returned.</p>
<p>If <code>totalLength</code> is not provided, it is calculated from the <code>Buffer</code> instances
in <code>list</code>. This however causes an additional loop to be executed in order to
calculate the <code>totalLength</code>, so it is faster to provide the length explicitly if
it is already known.</p>
<p>Example: Create a single <code>Buffer</code> from a list of three <code>Buffer</code> instances</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.alloc(<span class="hljs-number">10</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.alloc(<span class="hljs-number">14</span>);
<span class="hljs-keyword">const</span> buf3 = Buffer.alloc(<span class="hljs-number">18</span>);
<span class="hljs-keyword">const</span> totalLength = buf1.length + buf2.length + buf3.length;

<span class="hljs-comment">// Prints: 42</span>
<span class="hljs-built_in">console</span>.log(totalLength);

<span class="hljs-keyword">const</span> bufA = Buffer.concat([buf1, buf2, buf3], totalLength);

<span class="hljs-comment">// Prints: &lt;Buffer 00 00 00 00 ...&gt;</span>
<span class="hljs-built_in">console</span>.log(bufA);

<span class="hljs-comment">// Prints: 42</span>
<span class="hljs-built_in">console</span>.log(bufA.length);
</code></pre>
<h3 id="class-method-bufferfromarray">Class Method: Buffer.from(array)</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li><code>array</code> {Array}</li>
</ul>
<p>Allocates a new <code>Buffer</code> using an <code>array</code> of octets.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Creates a new Buffer containing ASCII bytes of the string &apos;buffer&apos;</span>
<span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x62</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>]);
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>array</code> is not an <code>Array</code>.</p>
<h3 id="class-method-bufferfromarraybuffer-byteoffset-length">Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li><code>arrayBuffer</code> {ArrayBuffer} The <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> or
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a></li>
<li><code>byteOffset</code> {Integer} Where to start copying from <code>arrayBuffer</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>length</code> {Integer} How many bytes to copy from <code>arrayBuffer</code>.
<strong>Default:</strong> <code>arrayBuffer.length - byteOffset</code></li>
</ul>
<p>When passed a reference to the <code>.buffer</code> property of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a> instance,
the newly created <code>Buffer</code> will share the same allocated memory as the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray" _target="blank"><code>TypedArray</code></a>.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint16Array</span>(<span class="hljs-number">2</span>);

arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5000</span>;
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">4000</span>;

<span class="hljs-comment">// Shares memory with `arr`</span>
<span class="hljs-keyword">const</span> buf = Buffer.from(arr.buffer);

<span class="hljs-comment">// Prints: &lt;Buffer 88 13 a0 0f&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

<span class="hljs-comment">// Changing the original Uint16Array changes the Buffer also</span>
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6000</span>;

<span class="hljs-comment">// Prints: &lt;Buffer 88 13 70 17&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<p>The optional <code>byteOffset</code> and <code>length</code> arguments specify a memory range within
the <code>arrayBuffer</code> that will be shared by the <code>Buffer</code>.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">10</span>);
<span class="hljs-keyword">const</span> buf = Buffer.from(ab, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// Prints: 2</span>
<span class="hljs-built_in">console</span>.log(buf.length);
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>arrayBuffer</code> is not an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" _target="blank"><code>ArrayBuffer</code></a>.</p>
<h3 id="class-method-bufferfrombuffer">Class Method: Buffer.from(buffer)</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li><code>buffer</code> {Buffer} An existing <code>Buffer</code> to copy data from</li>
</ul>
<p>Copies the passed <code>buffer</code> data onto a new <code>Buffer</code> instance.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from(<span class="hljs-string">&apos;buffer&apos;</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.from(buf1);

buf1[<span class="hljs-number">0</span>] = <span class="hljs-number">0x61</span>;

<span class="hljs-comment">// Prints: auffer</span>
<span class="hljs-built_in">console</span>.log(buf1.toString());

<span class="hljs-comment">// Prints: buffer</span>
<span class="hljs-built_in">console</span>.log(buf2.toString());
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>buffer</code> is not a <code>Buffer</code>.</p>
<h3 id="class-method-bufferfromstring-encoding">Class Method: Buffer.from(string[, encoding])</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li><code>string</code> {String} A string to encode.</li>
<li><code>encoding</code> {String} The encoding of <code>string</code>. <strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
</ul>
<p>Creates a new <code>Buffer</code> containing the given JavaScript string <code>string</code>. If
provided, the <code>encoding</code> parameter identifies the character encoding of <code>string</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from(<span class="hljs-string">&apos;this is a t&#xE9;st&apos;</span>);

<span class="hljs-comment">// Prints: this is a t&#xE9;st</span>
<span class="hljs-built_in">console</span>.log(buf1.toString());

<span class="hljs-comment">// Prints: this is a tC)st</span>
<span class="hljs-built_in">console</span>.log(buf1.toString(<span class="hljs-string">&apos;ascii&apos;</span>));


<span class="hljs-keyword">const</span> buf2 = Buffer.from(<span class="hljs-string">&apos;7468697320697320612074c3a97374&apos;</span>, <span class="hljs-string">&apos;hex&apos;</span>);

<span class="hljs-comment">// Prints: this is a t&#xE9;st</span>
<span class="hljs-built_in">console</span>.log(buf2.toString());
</code></pre>
<p>A <code>TypeError</code> will be thrown if <code>str</code> is not a string.</p>
<h3 id="class-method-bufferisbufferobj">Class Method: Buffer.isBuffer(obj)</h3>
<!-- YAML
added: v0.1.101
-->
<ul>
<li><code>obj</code> {Object}</li>
<li>Return: {Boolean}</li>
</ul>
<p>Returns <code>true</code> if <code>obj</code> is a <code>Buffer</code>, <code>false</code> otherwise.</p>
<h3 id="class-method-bufferisencodingencoding">Class Method: Buffer.isEncoding(encoding)</h3>
<!-- YAML
added: v0.9.1
-->
<ul>
<li><code>encoding</code> {String} A character encoding name to check</li>
<li>Return: {Boolean}</li>
</ul>
<p>Returns <code>true</code> if <code>encoding</code> contains a supported character encoding, or <code>false</code>
otherwise.</p>
<h3 id="class-property-bufferpoolsize">Class Property: Buffer.poolSize</h3>
<!-- YAML
added: v0.11.3
-->
<ul>
<li>{Integer} <strong>Default:</strong> <code>8192</code></li>
</ul>
<p>This is the number of bytes used to determine the size of pre-allocated, internal
<code>Buffer</code> instances used for pooling. This value may be modified.</p>
<h3 id="bufindex">buf[index]</h3>
<!-- YAML
type: property
name: [index]
-->
<p>The index operator <code>[index]</code> can be used to get and set the octet at position
<code>index</code> in <code>buf</code>. The values refer to individual bytes, so the legal value
range is between <code>0x00</code> and <code>0xFF</code> (hex) or <code>0</code> and <code>255</code> (decimal).</p>
<p>Example: Copy an ASCII string into a <code>Buffer</code>, one byte at a time</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&apos;Node.js&apos;</span>;
<span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(str.length);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length ; i++) {
  buf[i] = str.charCodeAt(i);
}

<span class="hljs-comment">// Prints: Node.js</span>
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">&apos;ascii&apos;</span>));
</code></pre>
<h3 id="bufcomparetarget-targetstart-targetend-sourcestart-sourceend">buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])</h3>
<!-- YAML
added: v0.11.13
-->
<ul>
<li><code>target</code> {Buffer} A <code>Buffer</code> to compare to</li>
<li><code>targetStart</code> {Integer} The offset within <code>target</code> at which to begin
comparison. <strong>Default:</strong> <code>0</code></li>
<li><code>targetEnd</code> {Integer} The offset with <code>target</code> at which to end comparison
(not inclusive). Ignored when <code>targetStart</code> is <code>undefined</code>.
<strong>Default:</strong> <code>target.length</code></li>
<li><code>sourceStart</code> {Integer} The offset within <code>buf</code> at which to begin comparison.
Ignored when <code>targetStart</code> is <code>undefined</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>sourceEnd</code> {Integer} The offset within <code>buf</code> at which to end comparison
(not inclusive). Ignored when <code>targetStart</code> is <code>undefined</code>.
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: {Integer}</li>
</ul>
<p>Compares <code>buf</code> with <code>target</code> and returns a number indicating whether <code>buf</code>
comes before, after, or is the same as <code>target</code> in sort order.
Comparison is based on the actual sequence of bytes in each <code>Buffer</code>.</p>
<ul>
<li><code>0</code> is returned if <code>target</code> is the same as <code>buf</code></li>
<li><code>1</code> is returned if <code>target</code> should come <em>before</em> <code>buf</code> when sorted.</li>
<li><code>-1</code> is returned if <code>target</code> should come <em>after</em> <code>buf</code> when sorted.</li>
</ul>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from(<span class="hljs-string">&apos;ABC&apos;</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.from(<span class="hljs-string">&apos;BCD&apos;</span>);
<span class="hljs-keyword">const</span> buf3 = Buffer.from(<span class="hljs-string">&apos;ABCD&apos;</span>);

<span class="hljs-comment">// Prints: 0</span>
<span class="hljs-built_in">console</span>.log(buf1.compare(buf1));

<span class="hljs-comment">// Prints: -1</span>
<span class="hljs-built_in">console</span>.log(buf1.compare(buf2));

<span class="hljs-comment">// Prints: -1</span>
<span class="hljs-built_in">console</span>.log(buf1.compare(buf3));

<span class="hljs-comment">// Prints: 1</span>
<span class="hljs-built_in">console</span>.log(buf2.compare(buf1));

<span class="hljs-comment">// Prints: 1</span>
<span class="hljs-built_in">console</span>.log(buf2.compare(buf3));

<span class="hljs-comment">// Prints: [ &lt;Buffer 41 42 43&gt;, &lt;Buffer 41 42 43 44&gt;, &lt;Buffer 42 43 44&gt; ]</span>
<span class="hljs-comment">// (This result is equal to: [buf1, buf3, buf2])</span>
<span class="hljs-built_in">console</span>.log([buf1, buf2, buf3].sort(Buffer.compare));
</code></pre>
<p>The optional <code>targetStart</code>, <code>targetEnd</code>, <code>sourceStart</code>, and <code>sourceEnd</code>
arguments can be used to limit the comparison to specific ranges within <code>target</code>
and <code>buf</code> respectively.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]);
<span class="hljs-keyword">const</span> buf2 = Buffer.from([<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);

<span class="hljs-comment">// Prints: 0</span>
<span class="hljs-built_in">console</span>.log(buf1.compare(buf2, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>));

<span class="hljs-comment">// Prints: -1</span>
<span class="hljs-built_in">console</span>.log(buf1.compare(buf2, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>));

<span class="hljs-comment">// Prints: 1</span>
<span class="hljs-built_in">console</span>.log(buf1.compare(buf2, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>));
</code></pre>
<p>A <code>RangeError</code> will be thrown if: <code>targetStart &lt; 0</code>, <code>sourceStart &lt; 0</code>,
<code>targetEnd &gt; target.byteLength</code> or <code>sourceEnd &gt; source.byteLength</code>.</p>
<h3 id="bufcopytarget-targetstart-sourcestart-sourceend">buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</h3>
<!-- YAML
added: v0.1.90
-->
<ul>
<li><code>target</code> {Buffer} A <code>Buffer</code> to copy into.</li>
<li><code>targetStart</code> {Integer} The offset within <code>target</code> at which to begin
copying to. <strong>Default:</strong> <code>0</code></li>
<li><code>sourceStart</code> {Integer} The offset within <code>buf</code> at which to begin copying from.
Ignored when <code>targetStart</code> is <code>undefined</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>sourceEnd</code> {Integer} The offset within <code>buf</code> at which to stop copying (not
inclusive). Ignored when <code>sourceStart</code> is <code>undefined</code>. <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: {Integer} The number of bytes copied.</li>
</ul>
<p>Copies data from a region of <code>buf</code> to a region in <code>target</code> even if the <code>target</code>
memory region overlaps with <code>buf</code>.</p>
<p>Example: Create two <code>Buffer</code> instances, <code>buf1</code> and <code>buf2</code>, and copy <code>buf1</code> from
byte 16 through byte 19 into <code>buf2</code>, starting at the 8th byte in <code>buf2</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.allocUnsafe(<span class="hljs-number">26</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.allocUnsafe(<span class="hljs-number">26</span>).fill(<span class="hljs-string">&apos;!&apos;</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  <span class="hljs-comment">// 97 is the decimal ASCII value for &apos;a&apos;</span>
  buf1[i] = i + <span class="hljs-number">97</span>;
}

buf1.copy(buf2, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">20</span>);

<span class="hljs-comment">// Prints: !!!!!!!!qrst!!!!!!!!!!!!!</span>
<span class="hljs-built_in">console</span>.log(buf2.toString(<span class="hljs-string">&apos;ascii&apos;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>));
</code></pre>
<p>Example: Create a single <code>Buffer</code> and copy data from one region to an
overlapping region within the same <code>Buffer</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">26</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  <span class="hljs-comment">// 97 is the decimal ASCII value for &apos;a&apos;</span>
  buf[i] = i + <span class="hljs-number">97</span>;
}

buf.copy(buf, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);

<span class="hljs-comment">// Prints: efghijghijklmnopqrstuvwxyz</span>
<span class="hljs-built_in">console</span>.log(buf.toString());
</code></pre>
<h3 id="bufentries">buf.entries()</h3>
<!-- YAML
added: v1.1.0
-->
<ul>
<li>Return: {Iterator}</li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" _target="blank">iterator</a> of <code>[index, byte]</code> pairs from the contents of
<code>buf</code>.</p>
<p>Example: Log the entire contents of a <code>Buffer</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;buffer&apos;</span>);

<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   [0, 98]</span>
<span class="hljs-comment">//   [1, 117]</span>
<span class="hljs-comment">//   [2, 102]</span>
<span class="hljs-comment">//   [3, 102]</span>
<span class="hljs-comment">//   [4, 101]</span>
<span class="hljs-comment">//   [5, 114]</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> pair <span class="hljs-keyword">of</span> buf.entries()) {
  <span class="hljs-built_in">console</span>.log(pair);
}
</code></pre>
<h3 id="bufequalsotherbuffer">buf.equals(otherBuffer)</h3>
<!-- YAML
added: v0.11.13
-->
<ul>
<li><code>otherBuffer</code> {Buffer} A <code>Buffer</code> to compare to</li>
<li>Return: {Boolean}</li>
</ul>
<p>Returns <code>true</code> if both <code>buf</code> and <code>otherBuffer</code> have exactly the same bytes,
<code>false</code> otherwise.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from(<span class="hljs-string">&apos;ABC&apos;</span>);
<span class="hljs-keyword">const</span> buf2 = Buffer.from(<span class="hljs-string">&apos;414243&apos;</span>, <span class="hljs-string">&apos;hex&apos;</span>);
<span class="hljs-keyword">const</span> buf3 = Buffer.from(<span class="hljs-string">&apos;ABCD&apos;</span>);

<span class="hljs-comment">// Prints: true</span>
<span class="hljs-built_in">console</span>.log(buf1.equals(buf2));

<span class="hljs-comment">// Prints: false</span>
<span class="hljs-built_in">console</span>.log(buf1.equals(buf3));
</code></pre>
<h3 id="buffillvalue-offset-end-encoding">buf.fill(value[, offset[, end]][, encoding])</h3>
<!-- YAML
added: v0.5.0
-->
<ul>
<li><code>value</code> {String | Buffer | Integer} The value to fill <code>buf</code> with</li>
<li><code>offset</code> {Integer} Where to start filling <code>buf</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>end</code> {Integer} Where to stop filling <code>buf</code> (not inclusive). <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li><code>encoding</code> {String} If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
<li>Return: {Buffer} A reference to <code>buf</code></li>
</ul>
<p>Fills <code>buf</code> with the specified <code>value</code>. If the <code>offset</code> and <code>end</code> are not given,
the entire <code>buf</code> will be filled. This is meant to be a small simplification to
allow the creation and filling of a <code>Buffer</code> to be done on a single line.</p>
<p>Example: Fill a <code>Buffer</code> with the ASCII character <code>&apos;h&apos;</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> b = Buffer.allocUnsafe(<span class="hljs-number">50</span>).fill(<span class="hljs-string">&apos;h&apos;</span>);

<span class="hljs-comment">// Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh</span>
<span class="hljs-built_in">console</span>.log(b.toString());
</code></pre>
<p><code>value</code> is coerced to a <code>uint32</code> value if it is not a String or Integer.</p>
<p>If the final write of a <code>fill()</code> operation falls on a multi-byte character,
then only the first bytes of that character that fit into <code>buf</code> are written.</p>
<p>Example: Fill a <code>Buffer</code> with a two-byte character</p>
<pre><code class="lang-js"><span class="hljs-comment">// Prints: &lt;Buffer c8 a2 c8&gt;</span>
<span class="hljs-built_in">console</span>.log(Buffer.allocUnsafe(<span class="hljs-number">3</span>).fill(<span class="hljs-string">&apos;\u0222&apos;</span>));
</code></pre>
<h3 id="bufindexofvalue-byteoffset-encoding">buf.indexOf(value[, byteOffset][, encoding])</h3>
<!-- YAML
added: v1.5.0
-->
<ul>
<li><code>value</code> {String | Buffer | Integer} What to search for</li>
<li><code>byteOffset</code> {Integer} Where to begin searching in <code>buf</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>encoding</code> {String} If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
<li>Return: {Integer} The index of the first occurrence of <code>value</code> in <code>buf</code> or <code>-1</code>
if <code>buf</code> does not contain <code>value</code></li>
</ul>
<p>If <code>value</code> is:</p>
<ul>
<li>a string, <code>value</code> is interpreted according to the character encoding in
<code>encoding</code>.</li>
<li>a <code>Buffer</code>, <code>value</code> will be used in its entirety. To compare a partial
<code>Buffer</code> use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a>.</li>
<li>a number, <code>value</code> will be interpreted as an unsigned 8-bit integer
value between <code>0</code> and <code>255</code>.</li>
</ul>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;this is a buffer&apos;</span>);

<span class="hljs-comment">// Prints: 0</span>
<span class="hljs-built_in">console</span>.log(buf.indexOf(<span class="hljs-string">&apos;this&apos;</span>)));

<span class="hljs-comment">// Prints: 2</span>
<span class="hljs-built_in">console</span>.log(buf.indexOf(<span class="hljs-string">&apos;is&apos;</span>));

<span class="hljs-comment">// Prints: 8</span>
<span class="hljs-built_in">console</span>.log(buf.indexOf(Buffer.from(<span class="hljs-string">&apos;a buffer&apos;</span>)));

<span class="hljs-comment">// Prints: 8</span>
<span class="hljs-comment">// (97 is the decimal ASCII value for &apos;a&apos;)</span>
<span class="hljs-built_in">console</span>.log(buf.indexOf(<span class="hljs-number">97</span>));

<span class="hljs-comment">// Prints: -1</span>
<span class="hljs-built_in">console</span>.log(buf.indexOf(Buffer.from(<span class="hljs-string">&apos;a buffer example&apos;</span>)));

<span class="hljs-comment">// Prints: 8</span>
<span class="hljs-built_in">console</span>.log(buf.indexOf(Buffer.from(<span class="hljs-string">&apos;a buffer example&apos;</span>).slice(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>)));


<span class="hljs-keyword">const</span> utf16Buffer = Buffer.from(<span class="hljs-string">&apos;\u039a\u0391\u03a3\u03a3\u0395&apos;</span>, <span class="hljs-string">&apos;ucs2&apos;</span>);

<span class="hljs-comment">// Prints: 4</span>
<span class="hljs-built_in">console</span>.log(utf16Buffer.indexOf(<span class="hljs-string">&apos;\u03a3&apos;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&apos;ucs2&apos;</span>));

<span class="hljs-comment">// Prints: 6</span>
<span class="hljs-built_in">console</span>.log(utf16Buffer.indexOf(<span class="hljs-string">&apos;\u03a3&apos;</span>, <span class="hljs-number">-4</span>, <span class="hljs-string">&apos;ucs2&apos;</span>));
</code></pre>
<h3 id="bufincludesvalue-byteoffset-encoding">buf.includes(value[, byteOffset][, encoding])</h3>
<!-- YAML
added: v5.3.0
-->
<ul>
<li><code>value</code> {String | Buffer | Integer} What to search for</li>
<li><code>byteOffset</code> {Integer} Where to begin searching in <code>buf</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>encoding</code> {String} If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
<li>Return: {Boolean} <code>true</code> if <code>value</code> was found in <code>buf</code>, <code>false</code> otherwise</li>
</ul>
<p>Equivalent to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf() !== -1</code></a>.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;this is a buffer&apos;</span>);

<span class="hljs-comment">// Prints: true</span>
<span class="hljs-built_in">console</span>.log(buf.includes(<span class="hljs-string">&apos;this&apos;</span>));

<span class="hljs-comment">// Prints: true</span>
<span class="hljs-built_in">console</span>.log(buf.includes(<span class="hljs-string">&apos;is&apos;</span>));

<span class="hljs-comment">// Prints: true</span>
<span class="hljs-built_in">console</span>.log(buf.includes(Buffer.from(<span class="hljs-string">&apos;a buffer&apos;</span>)));

<span class="hljs-comment">// Prints: true</span>
<span class="hljs-comment">// (97 is the decimal ASCII value for &apos;a&apos;)</span>
<span class="hljs-built_in">console</span>.log(buf.includes(<span class="hljs-number">97</span>));

<span class="hljs-comment">// Prints: false</span>
<span class="hljs-built_in">console</span>.log(buf.includes(Buffer.from(<span class="hljs-string">&apos;a buffer example&apos;</span>)));

<span class="hljs-comment">// Prints: true</span>
<span class="hljs-built_in">console</span>.log(buf.includes(Buffer.from(<span class="hljs-string">&apos;a buffer example&apos;</span>).slice(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>)));

<span class="hljs-comment">// Prints: false</span>
<span class="hljs-built_in">console</span>.log(buf.includes(<span class="hljs-string">&apos;this&apos;</span>, <span class="hljs-number">4</span>));
</code></pre>
<h3 id="bufkeys">buf.keys()</h3>
<!-- YAML
added: v1.1.0
-->
<ul>
<li>Return: {Iterator}</li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" _target="blank">iterator</a> of <code>buf</code> keys (indices).</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;buffer&apos;</span>);

<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   0</span>
<span class="hljs-comment">//   1</span>
<span class="hljs-comment">//   2</span>
<span class="hljs-comment">//   3</span>
<span class="hljs-comment">//   4</span>
<span class="hljs-comment">//   5</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">of</span> buf.keys()) {
  <span class="hljs-built_in">console</span>.log(key);
}
</code></pre>
<h3 id="buflastindexofvalue-byteoffset-encoding">buf.lastIndexOf(value[, byteOffset][, encoding])</h3>
<!-- YAML
added: v6.0.0
-->
<ul>
<li><code>value</code> {String | Buffer | Integer} What to search for</li>
<li><code>byteOffset</code> {Integer} Where to begin searching in <code>buf</code> (not inclusive).
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li><code>encoding</code> {String} If <code>value</code> is a string, this is its encoding.
<strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
<li>Return: {Integer} The index of the last occurrence of <code>value</code> in <code>buf</code> or <code>-1</code>
if <code>buf</code> does not contain <code>value</code></li>
</ul>
<p>Identical to <a href="#buffer_buf_indexof_value_byteoffset_encoding"><code>buf.indexOf()</code></a>, except <code>buf</code> is searched from back to front
instead of front to back.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;this buffer is a buffer&apos;</span>);

<span class="hljs-comment">// Prints: 0</span>
<span class="hljs-built_in">console</span>.log(buf.lastIndexOf(<span class="hljs-string">&apos;this&apos;</span>));

<span class="hljs-comment">// Prints: 17</span>
<span class="hljs-built_in">console</span>.log(buf.lastIndexOf(<span class="hljs-string">&apos;buffer&apos;</span>));

<span class="hljs-comment">// Prints: 17</span>
<span class="hljs-built_in">console</span>.log(buf.lastIndexOf(Buffer.from(<span class="hljs-string">&apos;buffer&apos;</span>)));

<span class="hljs-comment">// Prints: 15</span>
<span class="hljs-comment">// (97 is the decimal ASCII value for &apos;a&apos;)</span>
<span class="hljs-built_in">console</span>.log(buf.lastIndexOf(<span class="hljs-number">97</span>));

<span class="hljs-comment">// Prints: -1</span>
<span class="hljs-built_in">console</span>.log(buf.lastIndexOf(Buffer.from(<span class="hljs-string">&apos;yolo&apos;</span>)));

<span class="hljs-comment">// Prints: 5</span>
<span class="hljs-built_in">console</span>.log(buf.lastIndexOf(<span class="hljs-string">&apos;buffer&apos;</span>, <span class="hljs-number">5</span>));

<span class="hljs-comment">// Prints: -1</span>
<span class="hljs-built_in">console</span>.log(buf.lastIndexOf(<span class="hljs-string">&apos;buffer&apos;</span>, <span class="hljs-number">4</span>));


<span class="hljs-keyword">const</span> utf16Buffer = Buffer.from(<span class="hljs-string">&apos;\u039a\u0391\u03a3\u03a3\u0395&apos;</span>, <span class="hljs-string">&apos;ucs2&apos;</span>);

<span class="hljs-comment">// Prints: 6</span>
<span class="hljs-built_in">console</span>.log(utf16Buffer.lastIndexOf(<span class="hljs-string">&apos;\u03a3&apos;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&apos;ucs2&apos;</span>));

<span class="hljs-comment">// Prints: 4</span>
<span class="hljs-built_in">console</span>.log(utf16Buffer.lastIndexOf(<span class="hljs-string">&apos;\u03a3&apos;</span>, <span class="hljs-number">-5</span>, <span class="hljs-string">&apos;ucs2&apos;</span>));
</code></pre>
<h3 id="buflength">buf.length</h3>
<!-- YAML
added: v0.1.90
-->
<ul>
<li>{Integer}</li>
</ul>
<p>Returns the amount of memory allocated for <code>buf</code> in bytes. Note that this
does not necessarily reflect the amount of &quot;usable&quot; data within <code>buf</code>.</p>
<p>Example: Create a <code>Buffer</code> and write a shorter ASCII string to it</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.alloc(<span class="hljs-number">1234</span>);

<span class="hljs-comment">// Prints: 1234</span>
<span class="hljs-built_in">console</span>.log(buf.length);

buf.write(<span class="hljs-string">&apos;some string&apos;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&apos;ascii&apos;</span>);

<span class="hljs-comment">// Prints: 1234</span>
<span class="hljs-built_in">console</span>.log(buf.length);
</code></pre>
<p>While the <code>length</code> property is not immutable, changing the value of <code>length</code>
can result in undefined and inconsistent behavior. Applications that wish to
modify the length of a <code>Buffer</code> should therefore treat <code>length</code> as read-only and
use <a href="#buffer_buf_slice_start_end"><code>buf.slice()</code></a> to create a new <code>Buffer</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> buf = Buffer.allocUnsafe(<span class="hljs-number">10</span>);

buf.write(<span class="hljs-string">&apos;abcdefghj&apos;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&apos;ascii&apos;</span>);

<span class="hljs-comment">// Prints: 10</span>
<span class="hljs-built_in">console</span>.log(buf.length);

buf = buf.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);

<span class="hljs-comment">// Prints: 5</span>
<span class="hljs-built_in">console</span>.log(buf.length);
</code></pre>
<h3 id="bufreaddoublebeoffset-noassert">buf.readDoubleBE(offset[, noAssert])</h3>
<h3 id="bufreaddoubleleoffset-noassert">buf.readDoubleLE(offset[, noAssert])</h3>
<!-- YAML
added: v0.11.15
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Number}</li>
</ul>
<p>Reads a 64-bit double from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readDoubleBE()</code> returns big endian, <code>readDoubleLE()</code> returns
little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]);

<span class="hljs-comment">// Prints: 8.20788039913184e-304</span>
<span class="hljs-built_in">console</span>.log(buf.readDoubleBE());

<span class="hljs-comment">// Prints: 5.447603722011605e-270</span>
<span class="hljs-built_in">console</span>.log(buf.readDoubleLE());

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readDoubleLE(<span class="hljs-number">1</span>));

<span class="hljs-comment">// Warning: reads passed end of buffer!</span>
<span class="hljs-comment">// This will result in a segmentation fault! Don&apos;t do this!</span>
<span class="hljs-built_in">console</span>.log(buf.readDoubleLE(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>));
</code></pre>
<h3 id="bufreadfloatbeoffset-noassert">buf.readFloatBE(offset[, noAssert])</h3>
<h3 id="bufreadfloatleoffset-noassert">buf.readFloatLE(offset[, noAssert])</h3>
<!-- YAML
added: v0.11.15
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Number}</li>
</ul>
<p>Reads a 32-bit float from <code>buf</code> at the specified <code>offset</code> with specified
endian format (<code>readFloatBE()</code> returns big endian, <code>readFloatLE()</code> returns
little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);

<span class="hljs-comment">// Prints: 2.387939260590663e-38</span>
<span class="hljs-built_in">console</span>.log(buf.readFloatBE());

<span class="hljs-comment">// Prints: 1.539989614439558e-36</span>
<span class="hljs-built_in">console</span>.log(buf.readFloatLE());

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readFloatLE(<span class="hljs-number">1</span>));

<span class="hljs-comment">// Warning: reads passed end of buffer!</span>
<span class="hljs-comment">// This will result in a segmentation fault! Don&apos;t do this!</span>
<span class="hljs-built_in">console</span>.log(buf.readFloatLE(<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>));
</code></pre>
<h3 id="bufreadint8offset-noassert">buf.readInt8(offset[, noAssert])</h3>
<!-- YAML
added: v0.5.0
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads a signed 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&apos;s complement signed values.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">-1</span>, <span class="hljs-number">5</span>]);

<span class="hljs-comment">// Prints: -1</span>
<span class="hljs-built_in">console</span>.log(buf.readInt8(<span class="hljs-number">0</span>));

<span class="hljs-comment">// Prints: 5</span>
<span class="hljs-built_in">console</span>.log(buf.readInt8(<span class="hljs-number">1</span>));

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readInt8(<span class="hljs-number">2</span>));
</code></pre>
<h3 id="bufreadint16beoffset-noassert">buf.readInt16BE(offset[, noAssert])</h3>
<h3 id="bufreadint16leoffset-noassert">buf.readInt16LE(offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads a signed 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt16BE()</code> returns big endian,
<code>readInt16LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&apos;s complement signed values.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0</span>, <span class="hljs-number">5</span>]);

<span class="hljs-comment">// Prints: 5</span>
<span class="hljs-built_in">console</span>.log(buf.readInt16BE());

<span class="hljs-comment">// Prints: 1280</span>
<span class="hljs-built_in">console</span>.log(buf.readInt16LE(<span class="hljs-number">1</span>));

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readInt16LE(<span class="hljs-number">1</span>));
</code></pre>
<h3 id="bufreadint32beoffset-noassert">buf.readInt32BE(offset[, noAssert])</h3>
<h3 id="bufreadint32leoffset-noassert">buf.readInt32LE(offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads a signed 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
the specified endian format (<code>readInt32BE()</code> returns big endian,
<code>readInt32LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Integers read from a <code>Buffer</code> are interpreted as two&apos;s complement signed values.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>]);

<span class="hljs-comment">// Prints: 5</span>
<span class="hljs-built_in">console</span>.log(buf.readInt32BE());

<span class="hljs-comment">// Prints: 83886080</span>
<span class="hljs-built_in">console</span>.log(buf.readInt32LE());

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readInt32LE(<span class="hljs-number">1</span>));
</code></pre>
<h3 id="bufreadintbeoffset-bytelength-noassert">buf.readIntBE(offset, byteLength[, noAssert])</h3>
<h3 id="bufreadintleoffset-bytelength-noassert">buf.readIntLE(offset, byteLength[, noAssert])</h3>
<!-- YAML
added: v0.11.15
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Integer} How many bytes to read. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> and <code>byteLength</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as a two&apos;s complement signed value. Supports up to 48
bits of accuracy.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0xab</span>]);

<span class="hljs-comment">// Prints: 1234567890ab</span>
<span class="hljs-built_in">console</span>.log(buf.readIntLE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Prints: -546f87a9cbee</span>
<span class="hljs-built_in">console</span>.log(buf.readIntBE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readIntBE(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>));
</code></pre>
<h3 id="bufreaduint8offset-noassert">buf.readUInt8(offset[, noAssert])</h3>
<!-- YAML
added: v0.5.0
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads an unsigned 8-bit integer from <code>buf</code> at the specified <code>offset</code>.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>]);

<span class="hljs-comment">// Prints: 1</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt8(<span class="hljs-number">0</span>));

<span class="hljs-comment">// Prints: 254</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt8(<span class="hljs-number">1</span>));

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt8(<span class="hljs-number">2</span>));
</code></pre>
<h3 id="bufreaduint16beoffset-noassert">buf.readUInt16BE(offset[, noAssert])</h3>
<h3 id="bufreaduint16leoffset-noassert">buf.readUInt16LE(offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads an unsigned 16-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt16BE()</code> returns big endian, <code>readUInt16LE()</code>
returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x56</span>]);

<span class="hljs-comment">// Prints: 1234</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt16BE(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Prints: 3412</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt16LE(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Prints: 3456</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt16BE(<span class="hljs-number">1</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Prints: 5634</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt16LE(<span class="hljs-number">1</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt16LE(<span class="hljs-number">2</span>).toString(<span class="hljs-number">16</span>));
</code></pre>
<h3 id="bufreaduint32beoffset-noassert">buf.readUInt32BE(offset[, noAssert])</h3>
<h3 id="bufreaduint32leoffset-noassert">buf.readUInt32LE(offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads an unsigned 32-bit integer from <code>buf</code> at the specified <code>offset</code> with
specified endian format (<code>readUInt32BE()</code> returns big endian,
<code>readUInt32LE()</code> returns little endian).</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x78</span>]);

<span class="hljs-comment">// Prints: 12345678</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt32BE(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Prints: 78563412</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt32LE(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readUInt32LE(<span class="hljs-number">1</span>).toString(<span class="hljs-number">16</span>));
</code></pre>
<h3 id="bufreaduintbeoffset-bytelength-noassert">buf.readUIntBE(offset, byteLength[, noAssert])</h3>
<h3 id="bufreaduintleoffset-bytelength-noassert">buf.readUIntLE(offset, byteLength[, noAssert])</h3>
<!-- YAML
added: v0.11.15
-->
<ul>
<li><code>offset</code> {Integer} Where to start reading. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Integer} How many bytes to read. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>offset</code> and <code>byteLength</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer}</li>
</ul>
<p>Reads <code>byteLength</code> number of bytes from <code>buf</code> at the specified <code>offset</code>
and interprets the result as an unsigned integer. Supports up to 48
bits of accuracy.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows <code>offset</code> to be beyond the end of <code>buf</code>, but
the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x12</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0x56</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0xab</span>]);

<span class="hljs-comment">// Prints: 1234567890ab</span>
<span class="hljs-built_in">console</span>.log(buf.readUIntLE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Prints: ab9078563412</span>
<span class="hljs-built_in">console</span>.log(buf.readUIntBE(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>));

<span class="hljs-comment">// Throws an exception: RangeError: Index out of range</span>
<span class="hljs-built_in">console</span>.log(buf.readUIntBE(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>).toString(<span class="hljs-number">16</span>));
</code></pre>
<h3 id="bufslicestart-end">buf.slice([start[, end]])</h3>
<!-- YAML
added: v0.3.0
-->
<ul>
<li><code>start</code> {Integer} Where the new <code>Buffer</code> will start. <strong>Default:</strong> <code>0</code></li>
<li><code>end</code> {Integer} Where the new <code>Buffer</code> will end (not inclusive).
<strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: {Buffer}</li>
</ul>
<p>Returns a new <code>Buffer</code> that references the same memory as the original, but
offset and cropped by the <code>start</code> and <code>end</code> indices.</p>
<p><strong>Note that modifying the new <code>Buffer</code> slice will modify the memory in the
original <code>Buffer</code> because the allocated memory of the two objects overlap.</strong></p>
<p>Example: Create a <code>Buffer</code> with the ASCII alphabet, take a slice, and then modify
one byte from the original <code>Buffer</code></p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.allocUnsafe(<span class="hljs-number">26</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  <span class="hljs-comment">// 97 is the decimal ASCII value for &apos;a&apos;</span>
  buf1[i] = i + <span class="hljs-number">97</span>;
}

<span class="hljs-keyword">const</span> buf2 = buf1.slice(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);

<span class="hljs-comment">// Prints: abc</span>
<span class="hljs-built_in">console</span>.log(buf2.toString(<span class="hljs-string">&apos;ascii&apos;</span>, <span class="hljs-number">0</span>, buf2.length));

buf1[<span class="hljs-number">0</span>] = <span class="hljs-number">33</span>;

<span class="hljs-comment">// Prints: !bc</span>
<span class="hljs-built_in">console</span>.log(buf2.toString(<span class="hljs-string">&apos;ascii&apos;</span>, <span class="hljs-number">0</span>, buf2.length));
</code></pre>
<p>Specifying negative indexes causes the slice to be generated relative to the
end of <code>buf</code> rather than the beginning.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;buffer&apos;</span>);

<span class="hljs-comment">// Prints: buffe</span>
<span class="hljs-comment">// (Equivalent to buf.slice(0, 5))</span>
<span class="hljs-built_in">console</span>.log(buf.slice(<span class="hljs-number">-6</span>, <span class="hljs-number">-1</span>).toString());

<span class="hljs-comment">// Prints: buff</span>
<span class="hljs-comment">// (Equivalent to buf.slice(0, 4))</span>
<span class="hljs-built_in">console</span>.log(buf.slice(<span class="hljs-number">-6</span>, <span class="hljs-number">-2</span>).toString());

<span class="hljs-comment">// Prints: uff</span>
<span class="hljs-comment">// (Equivalent to buf.slice(1, 4))</span>
<span class="hljs-built_in">console</span>.log(buf.slice(<span class="hljs-number">-5</span>, <span class="hljs-number">-2</span>).toString());
</code></pre>
<h3 id="bufswap16">buf.swap16()</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li>Return: {Buffer} A reference to <code>buf</code></li>
</ul>
<p>Interprets <code>buf</code> as an array of unsigned 16-bit integers and swaps the byte-order
<em>in-place</em>. Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 2.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0x6</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x8</span>]);

<span class="hljs-comment">// Prints: &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);

buf1.swap16();

<span class="hljs-comment">// Prints: &lt;Buffer 02 01 04 03 06 05 08 07&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);


<span class="hljs-keyword">const</span> buf2 = Buffer.from([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>]);

<span class="hljs-comment">// Throws an exception: RangeError: Buffer size must be a multiple of 16-bits</span>
buf2.swap32();
</code></pre>
<h3 id="bufswap32">buf.swap32()</h3>
<!-- YAML
added: v5.10.0
-->
<ul>
<li>Return: {Buffer} A reference to <code>buf</code></li>
</ul>
<p>Interprets <code>buf</code> as an array of unsigned 32-bit integers and swaps the byte-order
<em>in-place</em>. Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 4.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0x6</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x8</span>]);

<span class="hljs-comment">// Prints &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);

buf1.swap32();

<span class="hljs-comment">// Prints &lt;Buffer 04 03 02 01 08 07 06 05&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);


<span class="hljs-keyword">const</span> buf2 = Buffer.from([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>]);

<span class="hljs-comment">// Throws an exception: RangeError: Buffer size must be a multiple of 32-bits</span>
buf2.swap32();
</code></pre>
<h3 id="bufswap64">buf.swap64()</h3>
<!-- YAML
added: v6.3.0
-->
<ul>
<li>Return: {Buffer} A reference to <code>buf</code></li>
</ul>
<p>Interprets <code>buf</code> as an array of 64-bit numbers and swaps the byte-order <em>in-place</em>.
Throws a <code>RangeError</code> if <a href="#buffer_buf_length"><code>buf.length</code></a> is not a multiple of 8.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.from([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x5</span>, <span class="hljs-number">0x6</span>, <span class="hljs-number">0x7</span>, <span class="hljs-number">0x8</span>]);

<span class="hljs-comment">// Prints &lt;Buffer 01 02 03 04 05 06 07 08&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);

buf1.swap64();

<span class="hljs-comment">// Prints &lt;Buffer 08 07 06 05 04 03 02 01&gt;</span>
<span class="hljs-built_in">console</span>.log(buf1);


<span class="hljs-keyword">const</span> buf2 = Buffer.from([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>]);

<span class="hljs-comment">// Throws an exception: RangeError: Buffer size must be a multiple of 64-bits</span>
buf2.swap64();
</code></pre>
<p>Note that JavaScript cannot encode 64-bit integers. This method is intended
for working with 64-bit floats.</p>
<h3 id="buftostringencoding-start-end">buf.toString([encoding[, start[, end]]])</h3>
<!-- YAML
added: v0.1.90
-->
<ul>
<li><code>encoding</code> {String} The character encoding to decode to. <strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
<li><code>start</code> {Integer} Where to start decoding. <strong>Default:</strong> <code>0</code></li>
<li><code>end</code> {Integer} Where to stop decoding (not inclusive). <strong>Default:</strong> <a href="#buffer_buf_length"><code>buf.length</code></a></li>
<li>Return: {String}</li>
</ul>
<p>Decodes <code>buf</code> to a string according to the specified character encoding in <code>encoding</code>.
<code>start</code> and <code>end</code> may be passed to decode only a subset of <code>buf</code>.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf1 = Buffer.allocUnsafe(<span class="hljs-number">26</span>);

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">26</span> ; i++) {
  <span class="hljs-comment">// 97 is the decimal ASCII value for &apos;a&apos;</span>
  buf1[i] = i + <span class="hljs-number">97</span>;
}

<span class="hljs-comment">// Prints: abcdefghijklmnopqrstuvwxyz</span>
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">&apos;ascii&apos;</span>));

<span class="hljs-comment">// Prints: abcde</span>
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">&apos;ascii&apos;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>));


<span class="hljs-keyword">const</span> buf2 = Buffer.from(<span class="hljs-string">&apos;t&#xE9;st&apos;</span>);

<span class="hljs-comment">// Prints: t&#xE9;s</span>
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-string">&apos;utf8&apos;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>));

<span class="hljs-comment">// Prints: t&#xE9;s</span>
<span class="hljs-built_in">console</span>.log(buf.toString(<span class="hljs-literal">undefined</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>));
</code></pre>
<h3 id="buftojson">buf.toJSON()</h3>
<!-- YAML
added: v0.9.2
-->
<ul>
<li>Return: {Object}</li>
</ul>
<p>Returns a JSON representation of <code>buf</code>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" _target="blank"><code>JSON.stringify()</code></a> implicitly calls
this function when stringifying a <code>Buffer</code> instance.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from([<span class="hljs-number">0x1</span>, <span class="hljs-number">0x2</span>, <span class="hljs-number">0x3</span>, <span class="hljs-number">0x4</span>, <span class="hljs-number">0x5</span>]);
<span class="hljs-keyword">const</span> json = <span class="hljs-built_in">JSON</span>.stringify(buf);

<span class="hljs-comment">// Prints: {&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]}</span>
<span class="hljs-built_in">console</span>.log(json);

<span class="hljs-keyword">const</span> copy = <span class="hljs-built_in">JSON</span>.parse(json, (key, value) =&gt; {
  <span class="hljs-keyword">return</span> value &amp;&amp; value.type === <span class="hljs-string">&apos;Buffer&apos;</span>
    ? Buffer.from(value.data)
    : value;
});

<span class="hljs-comment">// Prints: &lt;Buffer 01 02 03 04 05&gt;</span>
<span class="hljs-built_in">console</span>.log(copy);
</code></pre>
<h3 id="bufvalues">buf.values()</h3>
<!-- YAML
added: v1.1.0
-->
<ul>
<li>Return: {Iterator}</li>
</ul>
<p>Creates and returns an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" _target="blank">iterator</a> for <code>buf</code> values (bytes). This function is
called automatically when a <code>Buffer</code> is used in a <code>for..of</code> statement.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.from(<span class="hljs-string">&apos;buffer&apos;</span>);

<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   98</span>
<span class="hljs-comment">//   117</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   101</span>
<span class="hljs-comment">//   114</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> buf.values()) {
  <span class="hljs-built_in">console</span>.log(value);
}

<span class="hljs-comment">// Prints:</span>
<span class="hljs-comment">//   98</span>
<span class="hljs-comment">//   117</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   102</span>
<span class="hljs-comment">//   101</span>
<span class="hljs-comment">//   114</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> value <span class="hljs-keyword">of</span> buf) {
  <span class="hljs-built_in">console</span>.log(value);
}
</code></pre>
<h3 id="bufwritestring-offset-length-encoding">buf.write(string[, offset[, length]][, encoding])</h3>
<!-- YAML
added: v0.1.90
-->
<ul>
<li><code>string</code> {String} String to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing <code>string</code>. <strong>Default:</strong> <code>0</code></li>
<li><code>length</code> {Integer} How many bytes to write. <strong>Default:</strong> <code>buf.length - offset</code></li>
<li><code>encoding</code> {String} The character encoding of <code>string</code>. <strong>Default:</strong> <code>&apos;utf8&apos;</code></li>
<li>Return: {Integer} Number of bytes written</li>
</ul>
<p>Writes <code>string</code> to <code>buf</code> at <code>offset</code> according to the character encoding in <code>encoding</code>.
The <code>length</code> parameter is the number of bytes to write. If <code>buf</code> did not contain
enough space to fit the entire string, only a partial amount of <code>string</code> will
be written. However, partially encoded characters will not be written.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">256</span>);

<span class="hljs-keyword">const</span> len = buf.write(<span class="hljs-string">&apos;\u00bd + \u00bc = \u00be&apos;</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: 12 bytes: &#xBD; + &#xBC; = &#xBE;</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${len}</span> bytes: <span class="hljs-subst">${buf.toString(&apos;utf8&apos;, 0, len)}</span>`</span>);
</code></pre>
<h3 id="bufwritedoublebevalue-offset-noassert">buf.writeDoubleBE(value, offset[, noAssert])</h3>
<h3 id="bufwritedoublelevalue-offset-noassert">buf.writeDoubleLE(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.11.15
-->
<ul>
<li><code>value</code> {Number} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 8</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeDoubleBE()</code> writes big endian, <code>writeDoubleLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 64-bit double. Behavior is undefined when
<code>value</code> is anything other than a 64-bit double.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">8</span>);

buf.writeDoubleBE(<span class="hljs-number">0xdeadbeefcafebabe</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 43 eb d5 b7 dd f9 5f d7&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.writeDoubleLE(<span class="hljs-number">0xdeadbeefcafebabe</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer d7 5f f9 dd b7 d5 eb 43&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwritefloatbevalue-offset-noassert">buf.writeFloatBE(value, offset[, noAssert])</h3>
<h3 id="bufwritefloatlevalue-offset-noassert">buf.writeFloatLE(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.11.15
-->
<ul>
<li><code>value</code> {Number} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeFloatBE()</code> writes big endian, <code>writeFloatLE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid 32-bit float. Behavior is undefined when
<code>value</code> is anything other than a 32-bit float.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);

buf.writeFloatBE(<span class="hljs-number">0xcafebabe</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 4f 4a fe bb&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.writeFloatLE(<span class="hljs-number">0xcafebabe</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer bb fe 4a 4f&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteint8value-offset-noassert">buf.writeInt8(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.5.0
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a valid
signed 8-bit integer. Behavior is undefined when <code>value</code> is anything other than
a signed 8-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p><code>value</code> is interpreted and written as a two&apos;s complement signed integer.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">2</span>);

buf.writeInt8(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
buf.writeInt8(<span class="hljs-number">-2</span>, <span class="hljs-number">1</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 02 fe&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteint16bevalue-offset-noassert">buf.writeInt16BE(value, offset[, noAssert])</h3>
<h3 id="bufwriteint16levalue-offset-noassert">buf.writeInt16LE(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt16BE()</code> writes big endian, <code>writeInt16LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 16-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 16-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p><code>value</code> is interpreted and written as a two&apos;s complement signed integer.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);

buf.writeInt16BE(<span class="hljs-number">0x0102</span>, <span class="hljs-number">0</span>);
buf.writeInt16LE(<span class="hljs-number">0x0304</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 01 02 04 03&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteint32bevalue-offset-noassert">buf.writeInt32BE(value, offset[, noAssert])</h3>
<h3 id="bufwriteint32levalue-offset-noassert">buf.writeInt32LE(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeInt32BE()</code> writes big endian, <code>writeInt32LE()</code> writes little
endian). <code>value</code> <em>should</em> be a valid signed 32-bit integer. Behavior is undefined
when <code>value</code> is anything other than a signed 32-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p><code>value</code> is interpreted and written as a two&apos;s complement signed integer.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">8</span>);

buf.writeInt32BE(<span class="hljs-number">0x01020304</span>, <span class="hljs-number">0</span>);
buf.writeInt32LE(<span class="hljs-number">0x05060708</span>, <span class="hljs-number">4</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 01 02 03 04 08 07 06 05&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteintbevalue-offset-bytelength-noassert">buf.writeIntBE(value, offset, byteLength[, noAssert])</h3>
<h3 id="bufwriteintlevalue-offset-bytelength-noassert">buf.writeIntLE(value, offset, byteLength[, noAssert])</h3>
<!-- YAML
added: v0.11.15
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Integer} How many bytes to write. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code>, <code>offset</code>, and <code>byteLength</code> validation?
<strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than a signed integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">6</span>);

buf.writeUIntBE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.writeUIntLE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);

<span class="hljs-comment">// Prints: &lt;Buffer ab 90 78 56 34 12&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteuint8value-offset-noassert">buf.writeUInt8(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.5.0
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 1</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code>. <code>value</code> <em>should</em> be a
valid unsigned 8-bit integer. Behavior is undefined when <code>value</code> is anything
other than an unsigned 8-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);

buf.writeUInt8(<span class="hljs-number">0x3</span>, <span class="hljs-number">0</span>);
buf.writeUInt8(<span class="hljs-number">0x4</span>, <span class="hljs-number">1</span>);
buf.writeUInt8(<span class="hljs-number">0x23</span>, <span class="hljs-number">2</span>);
buf.writeUInt8(<span class="hljs-number">0x42</span>, <span class="hljs-number">3</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 03 04 23 42&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteuint16bevalue-offset-noassert">buf.writeUInt16BE(value, offset[, noAssert])</h3>
<h3 id="bufwriteuint16levalue-offset-noassert">buf.writeUInt16LE(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 2</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt16BE()</code> writes big endian, <code>writeUInt16LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 16-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 16-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);

buf.writeUInt16BE(<span class="hljs-number">0xdead</span>, <span class="hljs-number">0</span>);
buf.writeUInt16BE(<span class="hljs-number">0xbeef</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// Prints: &lt;Buffer de ad be ef&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.writeUInt16LE(<span class="hljs-number">0xdead</span>, <span class="hljs-number">0</span>);
buf.writeUInt16LE(<span class="hljs-number">0xbeef</span>, <span class="hljs-number">2</span>);

<span class="hljs-comment">// Prints: &lt;Buffer ad de ef be&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteuint32bevalue-offset-noassert">buf.writeUInt32BE(value, offset[, noAssert])</h3>
<h3 id="bufwriteuint32levalue-offset-noassert">buf.writeUInt32LE(value, offset[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - 4</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code> and <code>offset</code> validation? <strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>value</code> to <code>buf</code> at the specified <code>offset</code> with specified endian
format (<code>writeUInt32BE()</code> writes big endian, <code>writeUInt32LE()</code> writes little
endian). <code>value</code> should be a valid unsigned 32-bit integer. Behavior is
undefined when <code>value</code> is anything other than an unsigned 32-bit integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">4</span>);

buf.writeUInt32BE(<span class="hljs-number">0xfeedface</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer fe ed fa ce&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.writeUInt32LE(<span class="hljs-number">0xfeedface</span>, <span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer ce fa ed fe&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h3 id="bufwriteuintbevalue-offset-bytelength-noassert">buf.writeUIntBE(value, offset, byteLength[, noAssert])</h3>
<h3 id="bufwriteuintlevalue-offset-bytelength-noassert">buf.writeUIntLE(value, offset, byteLength[, noAssert])</h3>
<!-- YAML
added: v0.5.5
-->
<ul>
<li><code>value</code> {Integer} Number to be written to <code>buf</code></li>
<li><code>offset</code> {Integer} Where to start writing. Must satisfy: <code>0 &lt;= offset &lt;= buf.length - byteLength</code></li>
<li><code>byteLength</code> {Integer} How many bytes to write. Must satisfy: <code>0 &lt; byteLength &lt;= 6</code></li>
<li><code>noAssert</code> {Boolean} Skip <code>value</code>, <code>offset</code>, and <code>byteLength</code> validation?
<strong>Default:</strong> <code>false</code></li>
<li>Return: {Integer} <code>offset</code> plus the number of bytes written</li>
</ul>
<p>Writes <code>byteLength</code> bytes of <code>value</code> to <code>buf</code> at the specified <code>offset</code>.
Supports up to 48 bits of accuracy. Behavior is undefined when <code>value</code> is
anything other than an unsigned integer.</p>
<p>Setting <code>noAssert</code> to <code>true</code> allows the encoded form of <code>value</code> to extend beyond
the end of <code>buf</code>, but the result should be considered undefined behavior.</p>
<p>Examples:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">6</span>);

buf.writeUIntBE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 12 34 56 78 90 ab&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.writeUIntLE(<span class="hljs-number">0x1234567890ab</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);

<span class="hljs-comment">// Prints: &lt;Buffer ab 90 78 56 34 12&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>
<h2 id="bufferinspectmaxbytes">buffer.INSPECT_MAX_BYTES</h2>
<!-- YAML
added: v0.5.4
-->
<ul>
<li>{Integer} <strong>Default:</strong> <code>50</code></li>
</ul>
<p>Returns the maximum number of bytes that will be returned when
<code>buf.inspect()</code> is called. This can be overridden by user modules. See
<a href="util.html#util_util_inspect_object_options"><code>util.inspect()</code></a> for more details on <code>buf.inspect()</code> behavior.</p>
<p>Note that this is a property on the <code>buffer</code> module as returned by
<code>require(&apos;buffer&apos;)</code>, not on the <code>Buffer</code> global or a <code>Buffer</code> instance.</p>
<h2 id="bufferkmaxlength">buffer.kMaxLength</h2>
<!-- YAML
added: v3.0.0
-->
<ul>
<li>{Integer} The largest size allowed for a single <code>Buffer</code> instance</li>
</ul>
<p>On 32-bit architectures, this value is <code>(2^30)-1</code> (~1GB).
On 64-bit architectures, this value is <code>(2^31)-1</code> (~2GB).</p>
<h2 id="class-slowbuffer">Class: SlowBuffer</h2>
<!-- YAML
deprecated: v6.0.0
-->
<pre><code>Stability: 0 - Deprecated: Use [`Buffer.allocUnsafeSlow()`] instead.
</code></pre><p>Returns an un-pooled <code>Buffer</code>.</p>
<p>In order to avoid the garbage collection overhead of creating many individually
allocated <code>Buffer</code> instances, by default allocations under 4KB are sliced from a
single larger allocated object. This approach improves both performance and memory
usage since v8 does not need to track and cleanup as many <code>Persistent</code> objects.</p>
<p>In the case where a developer may need to retain a small chunk of memory from a
pool for an indeterminate amount of time, it may be appropriate to create an
un-pooled <code>Buffer</code> instance using <code>SlowBuffer</code> then copy out the relevant bits.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-comment">// Need to keep around a few small chunks of memory</span>
<span class="hljs-keyword">const</span> store = [];

socket.on(<span class="hljs-string">&apos;readable&apos;</span>, () =&gt; {
  <span class="hljs-keyword">const</span> data = socket.read();

  <span class="hljs-comment">// Allocate for retained data</span>
  <span class="hljs-keyword">const</span> sb = SlowBuffer(<span class="hljs-number">10</span>);

  <span class="hljs-comment">// Copy the data into the new allocation</span>
  data.copy(sb, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);

  store.push(sb);
});
</code></pre>
<p>Use of <code>SlowBuffer</code> should be used only as a last resort <em>after</em> a developer
has observed undue memory retention in their applications.</p>
<h3 id="new-slowbuffersize">new SlowBuffer(size)</h3>
<!-- YAML
deprecated: v6.0.0
-->
<pre><code>Stability: 0 - Deprecated: Use [`Buffer.allocUnsafeSlow()`] instead.
</code></pre><ul>
<li><code>size</code> {Integer} The desired length of the new <code>SlowBuffer</code></li>
</ul>
<p>Allocates a new <code>SlowBuffer</code> of <code>size</code> bytes. The <code>size</code> must be less than
or equal to the value of <a href="#buffer_buffer_kmaxlength"><code>buffer.kMaxLength</code></a>. Otherwise, a <a href="errors.html#errors_class_rangeerror"><code>RangeError</code></a> is
thrown. A zero-length <code>Buffer</code> will be created if <code>size &lt;= 0</code>.</p>
<p>The underlying memory for <code>SlowBuffer</code> instances is <em>not initialized</em>. The
contents of a newly created <code>SlowBuffer</code> are unknown and could contain
sensitive data. Use <a href="#buffer_buf_fill_value_offset_end_encoding"><code>buf.fill(0)</code></a> to initialize a <code>SlowBuffer</code> to zeroes.</p>
<p>Example:</p>
<pre><code class="lang-js"><span class="hljs-keyword">const</span> SlowBuffer = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;buffer&apos;</span>).SlowBuffer;

<span class="hljs-keyword">const</span> buf = <span class="hljs-keyword">new</span> SlowBuffer(<span class="hljs-number">5</span>);

<span class="hljs-comment">// Prints (contents may vary): &lt;Buffer 78 e0 82 02 01&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);

buf.fill(<span class="hljs-number">0</span>);

<span class="hljs-comment">// Prints: &lt;Buffer 00 00 00 00 00&gt;</span>
<span class="hljs-built_in">console</span>.log(buf);
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="assert.html" class="navigation navigation-prev " aria-label="Previous page: Assertion Testing">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="addons.html" class="navigation navigation-next " aria-label="Next page: C/C++ Addons">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Buffer","level":"1.5","depth":1,"next":{"title":"C/C++ Addons","level":"1.6","depth":1,"path":"addons.md","ref":"addons.md","articles":[]},"previous":{"title":"Assertion Testing","level":"1.4","depth":1,"path":"assert.md","ref":"assert.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-sharing","-fontsettings","-search-pro","-advanced-emoji","-github","-splitter","-toggle-chapters"],"styles":{"website":"styles/website.css"},"pluginsConfig":{"search-pro":{"cutWordLib":"nodejieba","defineWord":["Gitbook"]},"github":{"url":"https://github.com/laomu1988/fe-books"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"laomu1988@qq.com","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"fe-books","language":"zh-hans","gitbook":"*"},"file":{"path":"buffer.md","mtime":"2017-02-07T11:13:21.000Z","type":"markdown"},"gitbook":{"version":"3.1.0","time":"2017-02-26T05:58:20.482Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

<script>
	// 百度统计
	var _hmt = _hmt || [];
	(function () {
		var hm = document.createElement("script");
		hm.src = "//hm.baidu.com/hm.js?171566b3d4f03c9c68c8f2c7a42d4b0e";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hm, s);
	})();
</script>
<script src="/fe-books/server/index.js"></script>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    

    </body>
</html>

